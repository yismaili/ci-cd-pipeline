pipeline {
    agent any
    options {
        timeout(time: 1, unit: 'HOURS')
        timestamps()
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '10', daysToKeepStr: '30'))
    }
        parameters {
            string(name: 'ITEMNAME', defaultValue: 'test2', description: 'Item name')
            string(name: 'GIT_COMMIT_SHORT', defaultValue: '1034e0b', description: 'Git commit short')
            string(name: 'BUILD_NUMBER', defaultValue: '379', description: 'Build number')

            // string(name: 'GIT_COMMIT_SHORT', defaultValue: '5107796', description: 'Git commit short')
            // string(name: 'BUILD_NUMBER', defaultValue: '403', description: 'Build number')
            string(name: 'BRANCH', defaultValue: 'master', description: 'Branch name')
            string(name: 'NEXUS_ARTEFACT_URL', defaultValue: '192.168.100.75:8585', description: 'Nexus artifact URL')
            string(name: 'REPOSITORY_FRONTEND', defaultValue: 'ci-cd/frontend', description: 'Frontend repository')
            string(name: 'REPOSITORY_BACKEND', defaultValue: 'ci-cd/backend', description: 'Backend repository')
            string(name: 'IMAGES_TO_KEEP', defaultValue: '3', description: 'Number of Docker images to keep')
        }
        environment {
            GIT_COMMIT_SHORT = "${params.GIT_COMMIT_SHORT}"
            BUILD_NUMBER = "${params.BUILD_NUMBER}"
            BUILD_STATUS = "CD"
            ITEMNAME = "${params.ITEMNAME}"
            REPO_URL = "https://github.com/yismaili/ci-cd"
            BRANCH = "${params.BRANCH}"
            NEXUS_ARTEFACT_CREDENTIALS = 'nexus-credentials-id'
            GIT_CREDENTIALS_ID = 'github-pat'
            NEXUS_ARTEFACT_URL = "${params.NEXUS_ARTEFACT_URL}"
            REPOSITORY_FRONTEND = "${params.REPOSITORY_FRONTEND}"
            REPOSITORY_BACKEND = "${params.REPOSITORY_BACKEND}"
            IMAGES_TO_KEEP = "${params.IMAGES_TO_KEEP}"
            PRODUCTION_SERVER = 'root@192.168.100.76'
            DENTIALS_ID = 'production-ssh-credentials-id'
            WORKSPACE = pwd()
            DOCKER_IMAGES_INFO = "${WORKSPACE}/docker-image-info"
            ENV = "/var/lib/jenkins/workspace/env/"
        }

        stages {
            stage('Setup') {
                steps {
                    script {
                        def jobName = currentBuild.fullDisplayName.split(' ')[0]
                        env.CUSTOMNAME = env.GIT_BRANCH.split("/")[1]
                        env.APPNAME = sh(script: 'basename -s .git ${GIT_URL}', returnStdout: true).trim()
                        targetFolderArray = env.GIT_BRANCH.split("/")
                        targetFolder = targetFolderArray[targetFolderArray.size() - 1]
                        currentBuild.displayName = "${CUSTOMNAME}/${env.GIT_COMMIT_SHORT}-${env.BUILD_NUMBER}/CD" 
                        sh '''
                            sudo cp ${env.DOCKER_IMAGES_INFO}/docker-image-info.txt ${env.WORKSPACE}/${jobName}/docker-image-info.txt
                            // sudo chown jenkins:jenkins /var/lib/jenkins/workspace/test2/docker-image-info.txt
                        '''
                        stash includes: 'docker-image-info.txt', name: 'docker-image-info'
                    }
                }
            }

            stage('Retrieve Docker Image Info') {
                steps {
                    script {
                        unstash 'docker-image-info'
                        def dockerImageInfo = readFile('docker-image-info.txt').trim()
                        env.DOCKER_IMAGE = dockerImageInfo
                    }
                }
            }

            stage('Test') {
                steps {
                    script {
                        sh 'echo ":/"'
                    }
                }
            }

            // stage('Remove Unused Docker Images') {
            //     steps {
            //         script {
            //             try {
                            
            //                 def backendTags = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${NEXUS_ARTEFACT_URL}/${REPOSITORY_BACKEND}' || true", returnStdout: true).trim().split('\n').findAll { it }
            //                 def frontendTags = sh(script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep '${NEXUS_ARTEFACT_URL}/${REPOSITORY_FRONTEND}' || true", returnStdout: true).trim().split('\n').findAll { it }
                            
            //                 removeOldImages(backendTags, env.IMAGES_TO_KEEP, "backend")
            //                 removeOldImages(frontendTags, env.IMAGES_TO_KEEP, "frontend")

            //             } catch (Exception e) {
            //                 println "Error during image cleanup: ${e.message}"
            //             }
            //             sh 'echo "hi"'
            //         }
            //     }
            // }

            stage('Remove Unused Docker Images on Production') {
    steps {
        script {
            sshagent(credentials: ['production-ssh-credentials-id']) {
                sh """
                    ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} '
                        docker images --format "{{.Repository}}:{{.Tag}}" | grep "${NEXUS_ARTEFACT_URL}/${REPOSITORY_BACKEND}" > /home/prod/backend-images.txt &&
                        docker images --format "{{.Repository}}:{{.Tag}}" | grep "${NEXUS_ARTEFACT_URL}/${REPOSITORY_FRONTEND}" > /home/prod/frontend-images.txt
                    '
                """
                sh """
                    scp -o StrictHostKeyChecking=no ${PRODUCTION_SERVER}:/home/prod/backend-images.txt ${WORKSPACE}/backend-images.txt
                    scp -o StrictHostKeyChecking=no ${PRODUCTION_SERVER}:/home/prod/frontend-images.txt ${WORKSPACE}/frontend-images.txt
                """
                
                def backendTags = readFile("${WORKSPACE}/backend-images.txt").trim().split('\n').findAll { it }
                def frontendTags = readFile("${WORKSPACE}/frontend-images.txt").trim().split('\n').findAll { it }

                // Hypothetical function that removes old images and returns the updated list
                def removeOldImages = { tags, count, type ->
                    def sortedTags = tags.sort().reverse()
                    return sortedTags.take(count)
                }

                backendTags = removeOldImages(backendTags, env.IMAGES_TO_KEEP, "backend")
                frontendTags = removeOldImages(frontendTags, env.IMAGES_TO_KEEP, "frontend")

                writeFile file: "${WORKSPACE}/backend-images.txt", text: backendTags.join('\n')
                writeFile file: "${WORKSPACE}/frontend-images.txt", text: frontendTags.join('\n')

                sh """
                    scp -o StrictHostKeyChecking=no ${WORKSPACE}/backend-images.txt ${PRODUCTION_SERVER}:/home/prod/backend-images.txt
                    scp -o StrictHostKeyChecking=no ${WORKSPACE}/frontend-images.txt ${PRODUCTION_SERVER}:/home/prod/frontend-images.txt
                """

                sh """
                    ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} '
                        docker rmi -f \$(cat /home/prod/backend-images.txt) &&
                        docker rmi -f \$(cat /home/prod/frontend-images.txt)
                    '
                """
            }
        }
    }
}



           stage('Deploy to Production') {
            environment {
                NEXUS_USERNAME = 'admin'
                // I have to fetch the nexus password from jenkins credentials !!!!!!
                NEXUS_PASSWORD = 'c9c95cac0f@ismaili'
            }
            when {
                expression { env.BUILD_STATUS == 'CD' }
            }
            steps {
                script {
                    def nexusBackendTag = "${NEXUS_ARTEFACT_URL}/ci-cd/backend:backend-${env.DOCKER_IMAGE}"
                    def nexusFrontendTag = "${NEXUS_ARTEFACT_URL}/ci-cd/frontend:frontend-${env.DOCKER_IMAGE}"
                    
                    
                    sh "echo BACKEND_IMAGE=${nexusBackendTag} >> .env"
                    sh "echo FRONTEND_IMAGE=${nexusFrontendTag} >> .env"

                    sshagent(credentials: ['production-ssh-credentials-id']) {
                        sh """
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} 'docker login ${NEXUS_ARTEFACT_URL} -u ${NEXUS_USERNAME} -p ${NEXUS_PASSWORD}'
                        """
                        
                        sh """
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} 'mkdir -p /home/prod'
                            scp -o StrictHostKeyChecking=no ${WORKSPACE}/docker-compose.yml ${PRODUCTION_SERVER}:/home/prod/docker-compose.yml
                            scp -o StrictHostKeyChecking=no ${WORKSPACE}/.env ${PRODUCTION_SERVER}:/home/prod/.env
                        """
                        
                        sh """
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} 'docker-compose -f /home/prod/docker-compose.yml down'
                        """
                        
                        sh """
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} 'docker-compose -f /home/prod/docker-compose.yml up -d'
                        """
                        
                        sh """
                            ssh -o StrictHostKeyChecking=no ${PRODUCTION_SERVER} 'rm -rf /home/prod/'
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            echo 'One way or another, I have finished'
            deleteDir()
        }
        success {
            echo 'I succeeded :)'
        }
        unstable {
            echo 'I am unstable :/'
        }
        failure {
            echo 'I failed :('
        }
    }
}

def removeOldImages(imageTags, lastN, type) {
    // println "Input imageTags: ${imageTags}"
    // println "Input lastN: ${lastN}"
    // println "Input type: ${type}"
    if (imageTags) {
       // Split build numbers from image tags
        def buildNumbers = imageTags.collect { tag ->
            try {
                def parts = tag.split(':')
              //  println "Tag parts: ${parts}"
                def tagWithoutRepo = parts[2]
              //  println "Tag without repo: ${tagWithoutRepo}"
                def part_numbers = tagWithoutRepo.split('-')
                def buildNumberPart = part_numbers[2]
               // println "Build number part: ${buildNumberPart}"
                def buildNumber = buildNumberPart?.toInteger()
              // println "Build number: ${buildNumber}"
                [tag: tag, buildNumber: buildNumber]
            } catch (Exception e) {
                println "Error parsing tag: ${tag}, error: ${e.message}"
                [tag: tag, buildNumber: null]
            }
        }.findAll { it.buildNumber != null }
       //println "Build numbers list: ${buildNumbers}"

        //  sort the build numbers by order
        def n = buildNumbers.size()
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (buildNumbers[j].buildNumber > buildNumbers[j + 1].buildNumber) {
                    def temp = buildNumbers[j]
                    buildNumbers[j] = buildNumbers[j + 1]
                    buildNumbers[j + 1] = temp
                }
            }
        }
        // println "Sorted build numbers: ${buildNumbers}"
        // Determine images to remove
       def imagesToRemove = buildNumbers.take(buildNumbers.size() - lastN).collect { it.tag }

        // println "Images to remove: ${imagesToRemove}"

        if (imagesToRemove) {
            def command = "docker rmi -f ${imagesToRemove.join(' ')}"
            println "Docker remove command: ${command}"
            sh command
            println "Removed old ${type} images, keeping the last ${lastN}."
        } else {
            println "All ${type} images are among the last ${lastN} images."
        }
    } else {
        println "No ${type} images found."
    }
}
